module Horn.Entity(
    Entity
) where

--import              Record
--import              Record.Lens

--import              Data.Text
--import              Data.Vector
--import qualified    Data.Map.Strict as DMS
--
--import qualified    Hasql.Connection as HC
--import qualified    Hasql.Query as HQ
--import qualified    Hasql.Session as HS
--import qualified    Hasql.Encoders as HE
--import qualified    Hasql.Decoders as HD

class Field name dbType where
    getName :: Text
    getDbType :: Text
    isNullable :: Bool


-- mathematically "pure", description,
-- ??should be suitable for storing calculated columns?? - probably should be promoted to anonymous Entities instead
-- to keep this class more "math-low-level"
class (Monad self => FieldSet self) where
    getName :: Text

    getFields :: some tree-based implementation for fields algebra

    addFieldSet :: self -> FieldSet -> self

    leftJoinFieldSet :: self -> FieldSet -> self

    crossFieldSet :: self -> FieldSet -> self

    unionFieldSet :: self -> FieldSet -> MayBe Entity

    restrictFieldSetWhiteList :: self -> WhiteList -> self

    restrictFieldSetBlackList :: self -> BlackList -> self



-- mathematically "pure", description, but easily convertible to the pre-defined `ResultStream`
-- Proxy as a connection between the values world and types world
-- this can hold "anonymous" entities, like calculated columns
-- !!! TO BE ACTUALLY AUTOMATICALLY GENERATED BY POSTGRES ITSELF? the source files
class (FieldSet self => Entity self) where
    getName :: Proxy Entity -> Text

    -- the only required implementation method
    definition :: self (self-creation descripted in "FieldSet" primitives and serialized as a Haskell source file)

    pure :: Proxy Entity (Maybe | Empty | Undefined) -> self

    all :: Proxy Entity -> ResultStream

    new = pure Empty

    blackList :: BlackList
    whiteList :: WhiteList


-- only contains a set of "materialized" columns, like table/view definition in DB
-- !!! TO BE ACTUALLY AUTOMATICALLY GENERATED BY POSTGRES ITSELF? the source files
class (Entity self => Table self) where

-- actual result stream:
--      -- should return a browsable (Traversable) graph of results, with entry points of every Entity, participated in the creation
--      -- Traversable points for every relationship ?? TraversableStream

class (FieldSet self => ResultStream self) where
    where :: self -> Condition -> self

    runQuery :: Query -> Maybe ResultSet

    filter :: Query -> Maybe ResultStream

    entryPointForEntity :: Entity -> FieldSetStream


-- this is the primary interface for dealing with the results
class (FieldSet self => Object self)
    -- lenses I guess..
    -- all the sugar is here
    getValue :: self -> Field -> Value
    setValue :: self -> Field -> Value -> self

    readOnly :: Bool
    isModified :: Bool
    phantom :: Bool


-- this is the user
class FieldSetStream
    getEntity :: Entity

    getData :: self -> IO (Either Error (Stream Object))

    -- special lens as well?
    -- STM ? or TransactionableFieldSet
    followRelation :: self -> Proxy Relation -> self

    save :: self -> IO (Either Error self)


-- conduit / pipe
class Stream a
    forAll :: (Object -> a) -> b

-- etc
    shuffle ::
    sortBy ::
    first ::
    last ::
    reverse ::


------------------------------------------------------------------------------------------------------------------------
import qualified    Horn.Something as HS
import qualified    Horn.Operators(.==, .<)

import qualified    YourApp.DbSchema as DB


-- Person has many BlogPost

type Person     = HS.Entity "Person"

type Person     = DB.Person

some = do
    let query =
        (select DB.Person)
        `where` (DB.Person.id `.==` (??) HS.&& Person.name `like` 'asd')
        `orderBy` (HS.desc Person.id)
        `prefetch` DB.BlogPost
    in
        Vector objects <- doQuery query connection

        set ((object `as` Person).name) "newName"

